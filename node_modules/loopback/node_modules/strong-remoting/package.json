{
  "name": "strong-remoting",
  "description": "StrongLoop Remoting Module",
  "keywords": [
    "StrongLoop",
    "LoopBack",
    "Remoting",
    "REST"
  ],
  "version": "2.19.0",
  "scripts": {
    "pretest": "grunt jscs jshint",
    "test": "mocha"
  },
  "dependencies": {
    "express": "4.x",
    "body-parser": "^1.12.4",
    "debug": "^2.2.0",
    "eventemitter2": "^0.4.14",
    "cors": "^2.6.0",
    "jayson": "^1.2.0",
    "js2xmlparser": "^0.1.9",
    "async": "^0.9.0",
    "traverse": "^0.6.6",
    "request": "^2.55.0",
    "qs": "^2.4.2",
    "inflection": "^1.7.1",
    "xml2js": "^0.4.8"
  },
  "devDependencies": {
    "bluebird": "^2.9.25",
    "browserify": "~10.2.0",
    "chai": "^2.3.0",
    "grunt": "~0.4.5",
    "grunt-browserify": "~3.8.0",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-jshint": "^0.11.2",
    "grunt-contrib-uglify": "~0.9.1",
    "grunt-contrib-watch": "~0.6.1",
    "grunt-jscs": "^1.8.0",
    "grunt-karma": "~0.10.1",
    "http-auth": "^2.2.5",
    "karma": "~0.12.31",
    "karma-browserify": "4.1.2",
    "karma-chrome-launcher": "~0.1.12",
    "karma-coffee-preprocessor": "~0.2.1",
    "karma-firefox-launcher": "~0.1.6",
    "karma-html2js-preprocessor": "~0.1.0",
    "karma-jasmine": "~0.3.5",
    "karma-mocha": "~0.1.10",
    "karma-phantomjs-launcher": "~0.1.4",
    "karma-requirejs": "~0.2.2",
    "karma-script-launcher": "~0.1.0",
    "mocha": "~2.2.5",
    "requirejs": "~2.1.17",
    "socket.io": "~1.3.5",
    "supertest": "~1.0.1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/strongloop/strong-remoting"
  },
  "browser": {
    "express": false,
    "body-parser": false,
    "cors": false,
    "js2xmlparser": false
  },
  "license": {
    "name": "Dual MIT/StrongLoop",
    "url": "https://github.com/strongloop/strong-remoting/blob/master/LICENSE"
  },
  "readme": "## Overview\nObjects (and, therefore, data) in Node applications commonly need to be accessible by other Node processes, browsers, and even mobile clients.   Strong remoting:\n\n * Makes local functions remotable, exported over adapters.\n * Supports multiple transports, including custom transports.\n * Manages serialization to JSON and deserialization from JSON.\n * Supports multiple client SDKs, including mobile clients.\n\n<div class=\"confluence-hide\">\nAlso see the <a href=\"http://docs.strongloop.com/display/LB/Strong+Remoting\">official StrongLoop documentation</a>.</div>\n\n### Client SDK support\n\nFor higher-level transports, such as REST and Socket.IO, existing clients will work well. If you want to be able to swap out your transport, use one of our supported clients. The same adapter model available on the server applies to clients, so you can switch transports on both the server and all clients without changing your application-specific code.\n\n## Installation\n\n```sh\n$ npm install strong-remoting\n```\n\n##Quick start\n\nThe following example illustrates how to set up a basic strong-remoting server with a single remote method, user.greet.\n\n```js\n// Create a collection of remote objects.\nvar remoting = require('../');\nvar SharedClass = remoting.SharedClass\nvar remotes = remoting.create();\n\n// define a class-like object (or constructor)\nfunction User() {\n\n}\n\nUser.greet = function (fn) {\n  fn(null, 'hello, world!');\n}\n\n// create a shared class to allow strong-remoting to map\n// http requests to method invocations on your class\nvar userSharedClass = new SharedClass('user', User);\n\n// Tell strong-remoting about your greet method\nuserSharedClass.defineMethod('greet', {\n  isStatic: true, // not an instance method\n  returns: [{\n    arg: 'msg',\n    type: 'string' // define the type of the callback arguments\n  }]\n});\n// Expose it over the REST transport.\nrequire('http')\n  .createServer(remotes.handler('rest'))\n  .listen(3000);\n```\n\nThen, invoke `User.greet()` easily with `curl` (or any HTTP client)!\n\n    $ curl http://localhost:3000/user/greet?str=hello\n\nResult:\n\n```\n{\n  \"msg\": \"hello world\"\n}\n```\n\n##Concepts\n\n###Remote objects\n\nMost Node applications expose a remotely-available API.  Strong-remoting enables you to build your app in vanilla JavaScript and export remote objects over the network the same way you export functions from a module. Since they're just plain JavaScript objects, you can always invoke methods on your remote objects locally in JavaScript, whether from tests or other, local objects.\n\n###Remote object collections\n\nCollections that are the result of require('strong-remoting').create() are responsible for binding their remote objects to transports, allowing you to swap out the underlying transport without changing any of your application-specific code.\n\n###Adapters\n\nAdapters provide the transport-specific mechanisms to make remote objects (and collections thereof) available over their transport. The REST adapter, for example, handles an HTTP server and facilitates mapping your objects to RESTful resources. Other adapters, on the other hand, might provide a less opionated, RPC-style network interface. Your application code doesn't need to know what adapter it's using.\n\n###Hooks\n\nHooks enable you to run code before remote objects are constructed or methods on those objects are invoked. For example, you can prevent actions based on context (HTTP request, user credentials, and so on).\n\n```js\n// Do something before any hook is executed\nremotes.authorization = function(ctx, next) {\n  if(checkContext(ctx)) {\n    // allow\n    next();\n  } else {\n    // deny\n    var err = new Error('denied!');\n    err.statusCode = 401;\n    next(err);\n  }\n}\n\n// Do something before our `user.greet` example, earlier.\nremotes.before('user.greet', function (ctx, next) {\n  if((ctx.req.param('password') || '').toString() !== '1234') {\n    next(new Error('Bad password!'));\n  } else {\n    next();\n  }\n});\n\n// Do something before any `user` method.\nremotes.before('user.*', function (ctx, next) {\n  console.log('Calling a user method.');\n  next();\n});\n\n// Do something before a `dog` instance method.\nremotes.before('dog.prototype.*', function (ctx, next) {\n  var dog = this;\n  console.log('Calling a method on \"%s\".', dog.name);\n  next();\n});\n\n// Do something after the `speak` instance method.\n// NOTE: you cannot cancel a method after it has been called.\nremotes.after('dog.prototype.speak', function (ctx, next) {\n  console.log('After speak!');\n  next();\n});\n\n// Do something before all methods.\nremotes.before('**', function (ctx, next, method) {\n  console.log('Calling:', method.name);\n  next();\n});\n\n// Modify all returned values named `result`.\nremotes.after('**', function (ctx, next) {\n  ctx.result += '!!!';\n  next();\n});\n```\n\nSee the before-after example for more info.\n\n###Streams\n\nStrong-remoting supports methods that expect or return Readable and Writeable streams. This enables you to stream raw binary data such as files over the network without writing transport-specific behavior.\n\nFor example, the following code exposes a method of the `fs` Remote Object, `fs.createReadStream`, over the REST adapter:\n\n```js\n// Create a Collection.\nvar remotes = require('strong-remoting').create();\n\n// Share some fs module code.\nvar fs = remotes.exports.fs = require('fs');\n\n// Specifically export the `createReadStream` function.\nfs.createReadStream.shared = true;\n\n// Describe the arguments.\nfs.createReadStream.accepts = {arg: 'path', type: 'string'};\n\n// Describe the stream destination.\nfs.createReadStream.http = {\n  // Pipe the returned `Readable` stream to the response's `Writable` stream.\n  pipe: {\n    dest: 'res'\n  }\n};\n\n// Expose the Collection over the REST Adapter.\nrequire('http')\n  .createServer(remotes.handler('rest'))\n  .listen(3000);\n```\n\nThen you can invoke fs.createReadStream() using curl as follows:\n\n    $ curl http://localhost:3000/fs/createReadStream?path=some-file.txt\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/strongloop/strong-remoting/issues"
  },
  "homepage": "https://github.com/strongloop/strong-remoting",
  "_id": "strong-remoting@2.19.0",
  "_from": "strong-remoting@^2.15.0"
}
